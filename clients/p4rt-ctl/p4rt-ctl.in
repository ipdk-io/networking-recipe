#! @PYTHON3@
#
# Copyright (c) 2021-2023 Intel Corporation.
#
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

"""
p4rt-ctl utility controls P4 bridges.
"""
import argparse
import codecs
import grpc
import ipaddress
import logging
import math
import netaddr
import os
import queue
import random
import re
import socket
import string
import struct
import sys
import threading
import time
import fcntl
import select
from functools import wraps

import google.protobuf.text_format
from google.rpc import status_pb2, code_pb2

from p4.v1 import p4runtime_pb2
from p4.v1 import p4runtime_pb2_grpc
from p4.config.v1 import p4info_pb2

USAGE = """
p4rt-ctl: P4Runtime switch management utility
usage: p4rt-ctl [OPTIONS] COMMAND [ARG...]

for P4Runtime switches:
  show SWITCH                           shows P4Runtime switch information
  set-pipe SWITCH PROGRAM P4INFO        sets P4 pipeline for switch
  get-pipe SWITCH                       prints raw P4Info representation of
                                        P4 program
  add-entry SWITCH TABLE FLOW           adds new table entry
  del-entry SWITCH TABLE KEY            deletes table entry with KEY from TABLE
  dump-entries SWITCH [TBL]             prints table entries
  set-default-entry SWITCH TBL ACTION   sets default table entry for TBL
  get-default-entry SWITCH TBL          prints default table entry for TBL

  add-action-profile-member SWITCH PROFILE FLOW  adds member reference
  delete-action-profile-member SWITCH PROFILE FLOW  deletes member reference
  get-action-profile-member SWITCH PROFILE FLOW  prints member entries

  add-action-profile-group SWITCH PROFILE FLOW  adds group reference
  delete-action-profile-group SWITCH PROFILE FLOW  deletes group reference
  get-action-profile-group SWITCH PROFILE FLOW  prints group entries

  get-counter SWITCH CTR_TBL CTR_FLOW   gets indirect counter table entry
  get-direct-counter SWITCH CTR_TBL CTR_FLOW   gets direct counter table entry
  reset-counter SWITCH CTR_TBL CTR_FLOW resets counter table entry

  add-meter-config SWITCH MTR_TBL MTR_FLOW     add packet mod meter config table entry
  get-packet-mod-meter SWITCH MTR_TBL MTR_FLOW     gets packet mod meter table entry
  get-direct-pkt-mod-meter SWITCH MTR_TBL MTR_FLOW     gets direct packet mod meter table entry
"""

def usage():
    print(USAGE)
    sys.exit(0)

def valid_ip(address):
    try:
        socket.inet_aton(address)
        return True
    except:
        return False

class P4RuntimeErrorFormatException(Exception):
    def __init__(self, message):
        super().__init__(message)


# Used to iterate over the p4.Error messages in a gRPC error Status object
class P4RuntimeErrorIterator:
    def __init__(self, grpc_error):
        assert(grpc_error.code() == grpc.StatusCode.UNKNOWN) # nosec
        self.grpc_error = grpc_error

        error = None
        # The gRPC Python package does not have a convenient way to access the
        # binary details for the error: they are treated as trailing metadata.
        for meta in self.grpc_error.trailing_metadata():
            if meta[0] == "grpc-status-details-bin":
                error = status_pb2.Status()
                error.ParseFromString(meta[1])
                break
        if error is None:
            raise P4RuntimeErrorFormatException("No binary details field")

        if len(error.details) == 0:
            raise P4RuntimeErrorFormatException(
                "Binary details field has empty Any details repeated field")
        self.errors = error.details
        self.idx = 0

    def __iter__(self):
        return self

    def __next__(self):
        while self.idx < len(self.errors):
            p4_error = p4runtime_pb2.Error()
            one_error_any = self.errors[self.idx]
            if not one_error_any.Unpack(p4_error):
                raise P4RuntimeErrorFormatException(
                    "Cannot convert Any message to p4.Error")
            if p4_error.canonical_code == code_pb2.OK:
                continue
            v = self.idx, p4_error
            self.idx += 1
            return v
        raise StopIteration


class P4RuntimeWriteException(Exception):
    def __init__(self, grpc_error):
        assert(grpc_error.code() == grpc.StatusCode.UNKNOWN) # nosec
        super().__init__()
        self.errors = []
        try:
            error_iterator = P4RuntimeErrorIterator(grpc_error)
            for error_tuple in error_iterator:
                self.errors.append(error_tuple)
        except P4RuntimeErrorFormatException:
            raise  # just propagate exception for now

    def __str__(self):
        message = "Error(s) during Write:\n"
        for idx, p4_error in self.errors:
            code_name = code_pb2._CODE.values_by_number[
                p4_error.canonical_code].name
            message += "\t* At index {}: {}, '{}'\n".format(
                idx, code_name, p4_error.message)
        return message


class P4RuntimeException(Exception):
    def __init__(self, grpc_error):
        super().__init__()
        self.grpc_error = grpc_error

    def __str__(self):
        message = "P4Runtime RPC error ({}): {}".format(
            self.grpc_error.code().name, self.grpc_error.details())
        return message


def parse_p4runtime_write_error(f):
    @wraps(f)
    def handle(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except grpc.RpcError as e:
            if e.code() != grpc.StatusCode.UNKNOWN:
                raise e
            raise P4RuntimeWriteException(e) from None
    return handle


def parse_p4runtime_error(f):
    @wraps(f)
    def handle(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except grpc.RpcError as e:
            raise P4RuntimeException(e) from None
    return handle


mac_pattern = re.compile('^([\da-fA-F]{2}:){5}([\da-fA-F]{2})$')


def matchesMac(mac_addr_string):
    return mac_pattern.match(mac_addr_string) is not None


def encodeMac(mac_addr_string):
    str = mac_addr_string.replace(':', '')
    return codecs.decode(str, 'hex_codec')


def decodeMac(encoded_mac_addr):
    return ':'.join(codecs.encode(s, 'hex_codec').decode('utf-8')
                    for s in struct.unpack(str(len(encoded_mac_addr)) + 'c',
                                           encoded_mac_addr))


def decodeToHex(encoded_bytes):
    return '0x' + ''.join(codecs.encode(s, 'hex_codec').decode('utf-8')
                          for s in struct.unpack(str(len(encoded_bytes)) +
                                                 'c', encoded_bytes))


ip_pattern = re.compile('^(\d{1,3}\.){3}(\d{1,3})$')


def matchesIPv4(ip_addr_string):
    return ip_pattern.match(ip_addr_string) is not None


def encodeIPv4(ip_addr_string):
    return socket.inet_aton(ip_addr_string)


def encodeIPv4_base10(ip_addr_string):
    packedIP = socket.inet_aton(ip_addr_string)
    return struct.unpack("!L", packedIP)[0]


def decodeIPv4(encoded_ip_addr):
    return socket.inet_ntoa(encoded_ip_addr)

def matchesIPv6(ipv6_str):
    return netaddr.valid_ipv6(ipv6_str)

def encodeIPv6(ipv6_str):
    return socket.inet_pton(socket.AF_INET6,ipv6_str)

def decodeIPv6(encoded_ip_addr):
    return socket.inet_ntop(encoded_ip_addr)

def bitwidthToBytes(bitwidth):
    return int(math.ceil(bitwidth / 8.0))

def encodeNum(number, bitwidth):
    byte_len = bitwidthToBytes(bitwidth)
    num_str = '%x' % number
    if number >= 2 ** bitwidth:
        raise Exception("Number, %d, does not fit in %d bits" %
                        (number, bitwidth))
    val = ('0' * (byte_len * 2 - len(num_str)) + num_str)
    return codecs.decode(val, 'hex_codec')


def decodeNum(encoded_number):
    return int(codecs.encode(encoded_number, 'hex_codec'), 16)


def is_hex_str(hexa):
    return '0x'==hexa[:2] and all(val in string.hexdigits for val in hexa[2:])


def encode(x, bitwidth):
    'Tries to infer the type of `x` and encode it'
    byte_len = bitwidthToBytes(bitwidth)
    if (type(x) == list or type(x) == tuple) and len(x) == 1:
        x = x[0]
    encoded_bytes = None
    if type(x) == str:
        if matchesMac(x):
            encoded_bytes = encodeMac(x)
        elif matchesIPv4(x):
            encoded_bytes = encodeIPv4(x)
        elif matchesIPv6(x):
            encoded_bytes = encodeIPv6(x)
        elif str.isdigit(x):
            encoded_bytes = encodeNum(int(x), bitwidth)
        elif is_hex_str(x):
            encoded_bytes = encodeNum(int(x[2:], 16), bitwidth)
        else:
            # Assume that the string is already encoded
            encoded_bytes = x
    elif type(x) == int:
        encoded_bytes = encodeNum(x, bitwidth)
    else:
        raise Exception("Encoding objects of %r is not supported" % type(x))
    assert(len(encoded_bytes) == byte_len) # nosec
    return encoded_bytes


class P4InfoHelper(object):
    def __init__(self, p4info):
        self.p4info = p4info

    def get(self, entity_type, name=None, id=None):
        if name is not None and id is not None:
            raise AssertionError("name or id must be None")

        for o in getattr(self.p4info, entity_type):
            pre = o.preamble
            if name:
                if (pre.name == name or pre.alias == name):
                    return o
            else:
                if pre.id == id:
                    return o

        if name:
            raise AttributeError("Could not find %r of type %s" %
                                 (name, entity_type))
        else:
            raise AttributeError("Could not find id %r of type %s" %
                                 (id, entity_type))

    def get_id(self, entity_type, name):
        return self.get(entity_type, name=name).preamble.id

    def implementation_id(self, entity_type, name):
        return self.get(entity_type, name=name).implementation_id

    def get_name(self, entity_type, id):
        return self.get(entity_type, id=id).preamble.name

    def get_alias(self, entity_type, id):
        return self.get(entity_type, id=id).preamble.alias

    def __getattr__(self, attr):
        # Synthesize convenience functions for name to id lookups for top-level
        # entities
        # e.g. get_tables_id(name_string) or get_actions_id(name_string)
        m = re.search("^get_(\w+)_id$", attr)
        if m:
            primitive = m.group(1)
            return lambda name: self.get_id(primitive, name)

        # Synthesize convenience functions for id to name lookups
        # e.g. get_tables_name(id) or get_actions_name(id)
        m = re.search("^get_(\w+)_name$", attr)
        if m:
            primitive = m.group(1)
            return lambda id: self.get_name(primitive, id)

        raise AttributeError("%r object has no attribute %r" %
                             (self.__class__, attr))

    def get_match_fields(self, table_name):
        for t in self.p4info.tables:
            pre = t.preamble
            if pre.name == table_name:
                return t.match_fields

    def get_match_field(self, table_name, name=None, id=None):
        for t in self.p4info.tables:
            pre = t.preamble
            if pre.name == table_name:
                for mf in t.match_fields:
                    if name is not None:
                        if mf.name == name:
                            return mf
                    elif id is not None:
                        if mf.id == id:
                            return mf
        raise AttributeError("%r has no attribute %r" %
                             (table_name, name if name is not None else id))

    def get_match_field_id(self, table_name, match_field_name):
        return self.get_match_field(table_name, name=match_field_name).id

    def get_match_field_name(self, table_name, match_field_id):
        return self.get_match_field(table_name, id=match_field_id).name

    def get_match_field_width(self, table_name, match_field_name):
        return self.get_match_field(table_name, name=match_field_name).bitwidth

    def get_match_field_pb(self, table_name, match_field_name, value):
        p4info_match = self.get_match_field(table_name, match_field_name)
        bitwidth = p4info_match.bitwidth
        p4runtime_match = p4runtime_pb2.FieldMatch()
        p4runtime_match.field_id = p4info_match.id
        match_type = p4info_match.match_type

        if match_type == p4info_pb2.MatchField.EXACT:
            exact = p4runtime_match.exact
            exact.value = encode(value, bitwidth)
        elif match_type == p4info_pb2.MatchField.LPM:
            lpm = p4runtime_match.lpm
            lpm.value = encode(value[0], bitwidth)
            lpm.prefix_len = value[1]
        elif match_type == p4info_pb2.MatchField.TERNARY:
            lpm = p4runtime_match.ternary
            lpm.value = encode(value[0], bitwidth)
            lpm.mask = encode(value[1], bitwidth)
        elif match_type == p4info_pb2.MatchField.RANGE:
            lpm = p4runtime_match.range
            lpm.low = encode(value[0], bitwidth)
            lpm.high = encode(value[1], bitwidth)
        else:
            raise Exception("Unsupported match type with type %r" % match_type)
        return p4runtime_match

    def get_match_field_value(self, match_field):
        match_type = match_field.WhichOneof("field_match_type")
        if match_type == 'valid':
            return match_field.valid.value
        elif match_type == 'exact':
            return match_field.exact.value
        elif match_type == 'lpm':
            return (match_field.lpm.value, match_field.lpm.prefix_len)
        elif match_type == 'ternary':
            return (match_field.ternary.value, match_field.ternary.mask)
        elif match_type == 'range':
            return (match_field.range.low, match_field.range.high)
        else:
            raise Exception("Unsupported match type with type %r" % match_type)

    def get_action_params(self, action_name):
        for a in self.p4info.actions:
            pre = a.preamble
            if pre.name == action_name:
                return a.params

    def get_action_param(self, action_name, name=None, id=None):
        for a in self.p4info.actions:
            pre = a.preamble
            if pre.name == action_name:
                for p in a.params:
                    if name is not None:
                        if p.name == name:
                            return p
                    elif id is not None:
                        if p.id == id:
                            return p
        raise AttributeError("action %r has no param %r, (has: %r)" %
                             (action_name, name if name is not None else id,
                              a.params))

    def get_action_param_id(self, action_name, param_name):
        return self.get_action_param(action_name, name=param_name).id

    def get_action_param_name(self, action_name, param_id):
        return self.get_action_param(action_name, id=param_id).name

    def get_action_param_pb(self, action_name, param_name, value):
        p4info_param = self.get_action_param(action_name, param_name)
        p4runtime_param = p4runtime_pb2.Action.Param()
        p4runtime_param.param_id = p4info_param.id
        p4runtime_param.value = encode(value, p4info_param.bitwidth)
        return p4runtime_param

    def buildTableEntry(self,
                        table_name,
                        match_fields=None,
                        default_action=False,
                        action_name=None,
                        action_params=None,
                        priority=None,
                        group_id=0,
                        member_id=0,
                        config_data=None):
        one_match_type_is_ternary = False
        table_entry = p4runtime_pb2.TableEntry()
        table_entry.table_id = self.get_tables_id(table_name)

        for mfn, value in match_fields.items():
            # A table can contain more than one match filed and in such cases
            # if one match_type has ternary and other filed is of any type
            # it is considered as ternary match_type.
            # In these cases we expect priority field from the user.
            p4info_match = self.get_match_field(table_name, mfn)

            if p4info_match.match_type == p4info_pb2.MatchField.TERNARY:
                one_match_type_is_ternary = True
                # If match_type is ternary, then priority field is expected
                if priority == None:
                    print("For ternary match_type, priority field is needed")
                    sys.exit(1)

            if match_fields:
                table_entry.match.extend([
                    self.get_match_field_pb(table_name, mfn, value)
                ])

        if priority is not None and one_match_type_is_ternary:
            table_entry.priority = int(priority)

        if default_action:
            table_entry.is_default_action = True

        if action_name:
            action = table_entry.action.action
            action.action_id = self.get_actions_id(action_name)
            if action_params and action_params != ['']:
                action.params.extend([
                    self.get_action_param_pb(action_name, field_name, value)
                    for field_name, value in action_params.items()
                ])

        if member_id:
            table_entry.action.action_profile_member_id = member_id

        if group_id:
            table_entry.action.action_profile_group_id = group_id

        if config_data:
            datas = config_data.split(",")

            # Mapping of keys to attribute names
            attribute_mapping = {
            "policer_meter_prof_id": "policer_meter_prof_id",
            "policer_spec_cir_unit": "policer_spec_cir_unit",
            "policer_spec_cbs_unit": "policer_spec_cbs_unit",
            "policer_spec_eir_unit": "policer_spec_eir_unit",
            "policer_spec_ebs_unit": "policer_spec_ebs_unit",
            "policer_spec_cir": "policer_spec_cir",
            "policer_spec_cbs": "policer_spec_cbs",
            "policer_spec_eir": "policer_spec_eir",
            "policer_spec_ebs": "policer_spec_ebs"
            }

            meter_config = table_entry.meter_config.policer_meter_config

            # Iterate through the key-value pairs and set attributes
            for data in datas:
                key, value = data.strip().split("=")
                attribute_name = attribute_mapping.get(key)
                if attribute_name:
                    setattr(meter_config, attribute_name, int(value))

        return table_entry


    def buildActionProfileMember(self,
                        table_name,
                        member_id=0,
                        action_name=None,
                        action_params=None,
                        priority=None):
        action_profile_member = p4runtime_pb2.ActionProfileMember()

        action_profile_member.action_profile_id = self.get_action_profiles_id(table_name);
        action_profile_member.member_id = member_id

        if action_name:
            action = action_profile_member.action
            action.action_id = self.get_actions_id(action_name)
            if action_params:
                action.params.extend([
                    self.get_action_param_pb(action_name, field_name, value)
                    for field_name, value in action_params.items()
                ])

        return action_profile_member

    def buildActionProfileGroup(self,
                        table_name,
                        group_id=0,
                        max_size=0,
                        members=[]):

        action_profile_group = p4runtime_pb2.ActionProfileGroup()
        action_profile_group.action_profile_id = self.get_action_profiles_id(table_name);
        action_profile_group.group_id = group_id
        # If input for list of members is a comma speated values enclosed in
        # parenthesis. Here, remove the parenthesis and split members into
        # a list. Iterate over each member list and add to the group.
        #   Eg: reference_members=(11,22), this needs to be split into a list.
        # If Members is NULL (delete group), we dont need to split into each
        # member_id
        if members:
            member_list = members.replace("(","").replace(")","").split(",")
            for member_id in member_list:
                if str.isdigit(member_id):
                    apg = action_profile_group.members.add()
                    apg.member_id = int(member_id)
                else:
                    print("Member ID:", member_id, "should be numeric value.")
                    sys.exit(1)

        action_profile_group.max_size = max_size
        return action_profile_group

class P4RuntimeClient:

    def __init__(self, device_id, grpc_addr='localhost:9559',
                 election_id=(1, 0)):
        self.device_id = device_id
        self.election_id = election_id
        grpc_addr = str(grpc_server_addr)

        root_ca_file_path = '/usr/share/stratum/certs/ca.crt'
        client_key_file_path = '/usr/share/stratum/certs/client.key'
        client_crt_file_path = '/usr/share/stratum/certs/client.crt'

        rootca_exists = os.path.isfile(root_ca_file_path)
        clientkey_exists = os.path.isfile(client_key_file_path)
        clientcrt_exists = os.path.isfile(client_crt_file_path)

        if rootca_exists and clientkey_exists and clientcrt_exists:
            try:
                with open(root_ca_file_path, 'rb') as rootca:
                    with open(client_key_file_path, 'rb') as clientkey:
                        with open(client_crt_file_path, 'rb') as clientcrt:
                            creds = grpc.ssl_channel_credentials(rootca.read(), clientkey.read(), clientcrt.read())

                if creds is not None:
                    self.channel = grpc.secure_channel(grpc_addr, creds)
                else:
                    self.print_warning_message("Credentials error accessing certificate/key files", grpc_addr)
                    self.channel = grpc.insecure_channel(grpc_addr)
            except Exception as e:
                raise e
        else:
            self.print_warning_message("Unable to locate TLS certificates", grpc_addr)
            self.channel = grpc.insecure_channel(grpc_addr)

        self.stub = p4runtime_pb2_grpc.P4RuntimeStub(self.channel)
        self.set_up_stream()

    def print_warning_message(self, custom_text, grpc_insecure):
        print("*** Warning: " + custom_text + " ***")
        print("Attempting P4RT communication over insecure channel on port " + grpc_insecure + "...")

    def set_up_stream(self):
        self.stream_out_q = queue.Queue()
        self.stream_in_q = queue.Queue()

        def stream_req_iterator():
            while True:
                p = self.stream_out_q.get()
                if p is None:
                    break
                yield p

        def stream_recv_wrapper(stream):
            @parse_p4runtime_error
            def stream_recv():
                for p in stream:
                    self.stream_in_q.put(p)
            try:
                stream_recv()
            except P4RuntimeException as e:
                logging.critical("StreamChannel error, closing stream")
                logging.critical(e)
                self.stream_in_q.put(None)

        self.stream = self.stub.StreamChannel(stream_req_iterator())
        self.stream_recv_thread = threading.Thread(
            target=stream_recv_wrapper, args=(self.stream,))
        self.stream_recv_thread.start()

        self.handshake()

    def handshake(self):
        req = p4runtime_pb2.StreamMessageRequest()
        arbitration = req.arbitration
        arbitration.device_id = self.device_id
        election_id = arbitration.election_id
        election_id.high = self.election_id[0]
        election_id.low = self.election_id[1]
        self.stream_out_q.put(req)

        rep = self.get_stream_packet("arbitration", timeout=2)
        if rep is None:
            logging.critical("Failed to establish session with server")
            sys.exit(1)
        is_primary = (rep.arbitration.status.code == code_pb2.OK)
        logging.debug("Session established, client is '{}'".format(
            'primary' if is_primary else 'backup'))
        if not is_primary:
            print("You are not the primary client, you only have read access "
                  "to the server")

    def get_stream_packet(self, type_, timeout=1):
        start = time.time()
        try:
            while True:
                remaining = timeout - (time.time() - start)
                if remaining < 0:
                    break
                msg = self.stream_in_q.get(timeout=remaining)
                if msg is None:
                    return None
                if not msg.HasField(type_):
                    continue
                return msg
        except queue.Empty:  # timeout expired
            pass
        return None

    def get_packet_in(self, timeout=3):
        msg = self.get_stream_packet("packet", timeout)
        if msg is not None:
            return msg.packet

    def send_packet_out(self, payload):
        packet_out = p4runtime_pb2.PacketOut()
        packet_out.payload = payload
        packet_out_req = p4runtime_pb2.StreamMessageRequest()
        packet_out_req.packet.CopyFrom(packet_out)
        self.stream_out_q.put(packet_out_req)

    # Continuously poll for pkts from the server
    def pktio_rx(self, tap_device):
        print("Waiting for Rx packets...")
        while True:
            pkt = self.get_packet_in()
            if pkt is not None:
                tap_device.write(pkt.payload)

    @parse_p4runtime_error
    def get_p4info(self):
        req = p4runtime_pb2.GetForwardingPipelineConfigRequest()
        req.device_id = self.device_id
        req.response_type = p4runtime_pb2.GetForwardingPipelineConfigRequest. \
            P4INFO_AND_COOKIE
        rep = self.stub.GetForwardingPipelineConfig(req)
        return rep.config.p4info

    @parse_p4runtime_error
    def set_fwd_pipe_config(self, p4info_path, bin_path):
        req = p4runtime_pb2.SetForwardingPipelineConfigRequest()
        req.device_id = self.device_id
        election_id = req.election_id
        election_id.high = self.election_id[0]
        election_id.low = self.election_id[1]
        req.action = p4runtime_pb2.SetForwardingPipelineConfigRequest. \
            VERIFY_AND_COMMIT
        with open(p4info_path, 'r') as f1:
            with open(bin_path, 'rb') as f2:
                try:
                    google.protobuf.text_format.Merge(f1.read(),
                                                      req.config.p4info)
                except google.protobuf.text_format.ParseError:
                    logging.error("Error when parsing P4Info")
                    raise
                req.config.p4_device_config = f2.read()
        return self.stub.SetForwardingPipelineConfig(req)

    def tear_down(self):
        if self.stream_out_q:
            self.stream_out_q.put(None)
            self.stream_recv_thread.join()
        self.channel.close()
        # avoid a race condition if channel deleted when process terminates
        del self.channel

    @parse_p4runtime_write_error
    def write(self, req):
        req.device_id = self.device_id
        election_id = req.election_id
        election_id.high = self.election_id[0]
        election_id.low = self.election_id[1]
        return self.stub.Write(req)

    @parse_p4runtime_write_error
    def write_update(self, update):
        req = p4runtime_pb2.WriteRequest()
        req.device_id = self.device_id
        election_id = req.election_id
        election_id.high = self.election_id[0]
        election_id.low = self.election_id[1]
        req.updates.extend([update])
        return self.stub.Write(req)

    def read_one(self, entity):
        req = p4runtime_pb2.ReadRequest()
        req.device_id = self.device_id
        req.entities.extend([entity])
        return self.stub.Read(req)


def with_client(f):
    @wraps(f)
    def handle(*args, **kwargs):
        client = None
        try:
            client = P4RuntimeClient(device_id=1)
            f(client, *args, **kwargs)
        except Exception as e:
            raise e
        finally:
            if client:
                client.tear_down()
    return handle



@with_client
def p4ctl_show(client, bridge):
    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)

    bridge_line = "P4Runtime switch {} information:\n".format(bridge)
    device_id_line = "device_id: {}\n".format(client.device_id)
    n_tables_line = "n_tables: {}\n".format(len(p4info.tables))
    tables_line = "tables:"
    for tbl in p4info.tables:
        match = [mf.name for mf in tbl.match_fields]
        actions = [helper.get_name('actions', a.id) for a in tbl.action_refs]
        tables_line += " {}(match=[{}], actions=[{}])".format(
                        tbl.preamble.name, ', '.join(match),
                        ', '.join(actions))
    tables_line += "\n"

    print(''.join([bridge_line,
                   device_id_line,
                   n_tables_line,
                   tables_line,
                   '\n'.join(ports)]))


@with_client
def p4ctl_set_pipe(client, bridge, device_config, p4info):
    client.set_fwd_pipe_config(p4info, device_config)

class TapDevice:
    def __init__(self, tap_name):

        self.tap_name = tap_name

        # constants derived from
        # https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/if_tun.h#L34
        TUNSETIFF = 0x400454CA
        IFF_TAP = 0x0002
        IFF_NO_PI = 0x1000
        try:
            self.tap = os.open("/dev/net/tun", os.O_RDWR)

            # Configure the TAP interface.
            ifr = struct.pack('16sH', self.tap_name.encode(), IFF_TAP | IFF_NO_PI)
            fcntl.ioctl(self.tap, TUNSETIFF, ifr)

            print(f"Created TAP device {self.tap_name}")
        except Exception as e:
            print(f"Error creating TAP interface: {e}")
            if self.tap is not None:
                 os.close(self.tap)

    # Continuously reads pkts from TAP port and sends them out to the server
    def read(self, client):
        MAX_FRAME_SIZE = 1500
        SELECT_TIMEOUT = 0.1
        while True:
            readable, _, _ = select.select([self.tap], [], [], SELECT_TIMEOUT)
            if self.tap in readable:
                # read pkt from tap port
                data = os.read(self.tap, MAX_FRAME_SIZE)

                # send the packet to the server
                client.send_packet_out(data)

    # Sends pkts to the tap port
    def write(self, data):
        os.write(self.tap, data)

# Thread function to read pkts from TAP port
def read_from_tap(tap, client):
    print("Tx thread polling on TAP port")
    tap.read(client)

@with_client
def p4ctl_start_pktio(client, bridge):
    try:
        tap_device = TapDevice("pktioTap0")
        tx_thread = threading.Thread(target=read_from_tap, args=(tap_device,client))
        tx_thread.start()
        client.pktio_rx(tap_device)
    except Exception as e:
        print(f"Error: Failed to start packetIo {e}")

@with_client
def p4ctl_get_pipe(client, bridge):
    p4info = client.get_p4info()
    if p4info:
        print("P4Info of bridge {}:".format(bridge))
        print(p4info)


def parse_match_key(key):
    match_keys = dict()
    mk_fields = key.split(",")
    for mk_field in mk_fields:
            m = mk_field.split("=")
            if "/" in m[1]:
                lpm_mk = m[1].split("/")
                match_keys[m[0]] = (lpm_mk[0], int(lpm_mk[1]))
            else:
                match_keys[m[0]] = m[1]
    return match_keys


def parse_match_key_ternary(matchkey):
    m_key = matchkey.split(",priority=")
    key = m_key[0]
    priority = m_key[1]
    match_keys = dict()
    mk_fields = key.split(",")
    for mk_field in mk_fields:
            m = mk_field.split("=")
            if "/" in m[1]:
                lpm_mk = m[1].split("/")
                if (str.isdigit(lpm_mk[1])):
                    match_keys[m[0]] = (lpm_mk[0], int(lpm_mk[1]))
                else:
                    match_keys[m[0]] = (lpm_mk[0], lpm_mk[1])
            else:
                match_keys[m[0]] = m[1]
    return match_keys, priority


def parse_action(action, helper):
    """
    Accepted input types for action values are
    IP - String, Hex or Decimal
    MAC - String, Hex or Decimal
    Other - Hex Or Decimal
    """
    act_fields = action.split('(')
    action_name = act_fields[0]
    if (len(act_fields) > 1):

        params = act_fields[1].split(')')[0]
        act_data = params.split(',')

        # One limitation with this client code is, user should pass all the
        # action params associated with an action. Especially in case of lookup
        # entries, we will have more params. Example mirroring.p4 program has
        # around 45 params. Even though user is not going to program all
        # params, current code expects user to program all 45 params.
        # To avoid this, a logic is added where user can pass comma seperated
        # <action_param_name>=<action_param_value>, this code will loop through
        # available params and add values accordingly. Params which are not
        # specified by user will default to 0.
        #
        # Existing command:
        # action=my_control.mir_prof_action(0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,
        #                                   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        #                                   0,0,0,0,0,0,0,0,0)
        #
        # Command after the change:
        # action=my_control.mir_prof_action(port_id=1,mode=0,port_dest_type=0,
        #                                   dest_id=1,func_valid=1,store_vsi=1)
        if act_data[0].find('=') != -1:
            act_values = act_data
            for av in helper.p4info.actions:
                pre = av.preamble
                if pre.name == action_name:
                    act_data = ['0']*len(av.params)
                    for p in av.params:
                        for act in act_values:
                            act_info = act.split('=')
                            if p.name == act_info[0]:
                                act_data[p.id-1]=act_info[1]

        act_data = [encodeIPv4_base10(a) if matchesIPv4(a) else
            (int.from_bytes(encodeIPv6(a), "big") if matchesIPv6(a) else
            (int.from_bytes(encodeMac(a), "big") if matchesMac(a) else
            (int(a, 0) if a.find("0x") != -1 else int(a))))
            for a in act_data]
    else:
        act_data = ['']
    return action_name, act_data

def parse_flow(flow, helper):
    tmp = flow.split(",action=")
    mk = tmp[0]
    act = tmp[1]

    match_keys = parse_match_key(mk)
    action_name, act_data = parse_action(act, helper)
    return match_keys, action_name, act_data

def parse_flow_ternary(flow, helper):
    tmp = flow.split(",action=")
    mk = tmp[0]
    act = tmp[1]

    match_keys, priority = parse_match_key_ternary(mk)
    action_name, act_data = parse_action(act, helper)
    return match_keys, priority, action_name, act_data

def parse_flow_as(flow):
    if ("priority" in flow):
        print("Priority key is not expected in programming action profiles");
        sys.exit(1)
    elif ("group_id" in flow):
        # Use group_id for tokenizing
        extract_mk = flow.split(",group_id=")
        key = "group_id"
    elif ("member_id" in flow):
        # Use member_id for tokenizing
        extract_mk = flow.split(",member_id=")
        key = "member_id"
    else:
        raise AssertionError("group_id or member_id is expected")
    mk = extract_mk[0]
    act = extract_mk[1]
    action_name = None
    act_data = None
    group_id = 0
    member_id = 0

    if key == "action":
        action_name, act_data = parse_action(act)
    elif key == "group_id":
        group_id = act
    elif key == "member_id":
        member_id = act

    match_keys = parse_match_key(mk)
    return match_keys, action_name, act_data, group_id, member_id

def parse_profile_mem(flow):
    extract_mem = flow.split(",member_id=")
    action_param = extract_mem[0]
    mem_id = extract_mem[1]

    act = action_param.split("action=")
    action_name, act_data = parse_action(act[1])
    return action_name, act_data, mem_id

def parse_profile_group(flow):
    extract_group = flow.split(",reference_members=")
    group_id = extract_group[0].split("group_id=")
    mem = extract_group[1].split(",max_size=")

    ref_members = mem[0]
    max_size = mem[1]
    return group_id[1], ref_members, max_size

def parse_match_key_configData(matchkey):
    m_key = matchkey.split(",config_data=")
    key = m_key[0]
    config_data = m_key[1]
    match_keys = dict()
    mk_fields = key.split(",")

    for mk_field in mk_fields:
        m = mk_field.split("=")
        if "/" in m[1]:
            lpm_mk = m[1].split("/")
            match_keys[m[0]] = (lpm_mk[0], int(lpm_mk[1]))
        else:
            match_keys[m[0]] = m[1]
    return match_keys, config_data

def parse_flow_meter(flow, helper):
    tmp = flow.split(",action=")
    mk = tmp[0]
    act = tmp[1]

    match_keys, config_data = parse_match_key_configData(mk)
    action_name, act_data = parse_action(act, helper)
    return match_keys, config_data, action_name, act_data

@with_client
def p4ctl_add_entry(client, bridge, tbl_name, flow):
    """
    add-entry SWITCH TABLE MATCH_KEY ACTION ACTION_DATA
    Example:
        p4rt-ctl add-entry br0 pipe.filter_tbl
                    headers.ipv4.dstAddr=10.10.10.10,action=pipe.push_mpls(10)
    """
    config_data = None
    priority_val = None
    grp_id = 0
    mem_id = 0

    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)

    if (flow.find(",group_id") != -1 or flow.find(",member_id") != -1):
        # For TableAction when we use type as action_profile_member_id or
        # action_profile_group_id, p4rt-ctl expects either group_id or
        # member_id as part of flow. Hence delimiter as 'action=' doesnt work
        # here. Use parse_flow_as in this case, where we use ',' as a delimiter
        match_keys, action, action_data, grp_id, mem_id = parse_flow_as(flow)
    elif (flow.find("priority") != -1):
        # For match_type ternary, we expect priority to be programmed by user.
        match_keys, priority_val, action, action_data = parse_flow_ternary(flow, helper)
    elif (flow.find("config_data") != -1):
        # For meter, we expect config data to be programmed by user.
        match_keys, config_data, action, action_data = parse_flow_meter(flow, helper)

    else:
        # For TableAction when we use type as Action, p4rt-ctl expects flow to
        # have an 'action=' configured. In this parse_flow, we use 'action=' as
        # a delimiter.
        match_keys, action, action_data = parse_flow(flow, helper)

    te = helper.buildTableEntry(
        table_name=tbl_name,
        match_fields=match_keys,
        action_name=action,
        action_params=action_data
                       if (action_data==None or action_data==[''])
                       else {a.name: int(action_data[idx]) for idx,
                       a in enumerate(helper.get_action_params(action))},
        priority=priority_val,
        group_id=int(grp_id),
        member_id=int(mem_id),
        config_data=config_data)

    update = p4runtime_pb2.Update()
    update.type = p4runtime_pb2.Update.INSERT
    update.entity.table_entry.CopyFrom(te)

    client.write_update(update)

def parse_meter_configData(flow):
    tmp = flow.split(",meter_config=")
    key = tmp[0]
    config_data = tmp[1]

    mk_fields = key.split(",")
    mtr_id_str = mk_fields[0].split("=")
    index_str = mk_fields[1].split("=")
    meter_id=mtr_id_str[1]
    index=index_str[1]

    return meter_id, index, config_data

@with_client
def p4ctl_add_meter_config(client, bridge, tbl_name, flow):
    """
    add-entry SWITCH TABLE MATCH_KEY ACTION ACTION_DATA
    Example:
        ./setup/bin/p4rt-ctl add-meter-config br0 my_control.meter1 "meter_id=2244878476,  meter_index=6,meter_config=policer_meter_prof_id=0,policer_spec_cir_unit=0,policer_spec_cbs_unit=1,policer_spec_eir_unit=0,policer_spec_ebs_unit=1,policer_spec_cir=100,policer_spec_cbs=1500,policer_spec_eir=100,policer_spec_ebs=1500"
    """
    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)
    if (flow.find("meter_config") != -1):
        # For meter, we expect meter_index and config data to be programmed by user.
        meter_id, index, config_data = parse_meter_configData(flow)
    entity = p4runtime_pb2.Entity()
    ce = entity.meter_entry

    if ce is None:
        raise Exception("Cannot find meter_entry field in entity")

    ce.index.index = int(index)
    ce.meter_id = int(meter_id)
    datas = config_data.split(",")

    # Mapping of keys to attribute names
    attribute_mapping = {
    "policer_meter_prof_id": "policer_meter_prof_id",
    "policer_spec_cir_unit": "policer_spec_cir_unit",
    "policer_spec_cbs_unit": "policer_spec_cbs_unit",
    "policer_spec_eir_unit": "policer_spec_eir_unit",
    "policer_spec_ebs_unit": "policer_spec_ebs_unit",
    "policer_spec_cir": "policer_spec_cir",
    "policer_spec_cbs": "policer_spec_cbs",
    "policer_spec_eir": "policer_spec_eir",
    "policer_spec_ebs": "policer_spec_ebs"
    }
    # Iterate through the key-value pairs and set attributes
    for data in datas:
        key, value = data.strip().split("=")
        attribute_name = attribute_mapping.get(key)
        if attribute_name:
            setattr(ce.config.policer_meter_config, attribute_name, int(value))

    # Send a write() request
    update = p4runtime_pb2.Update()
    update.type = p4runtime_pb2.Update.MODIFY
    update.entity.meter_entry.CopyFrom(ce)

    client.write_update(update)

@with_client
def p4ctl_mod_entry(client, bridge, tbl_name, flow):
    """
    mod-entry SWITCH TABLE MATCH_KEY ACTION ACTION_DATA
    Example:
        p4rt-ctl mod-entry br0 pipe.filter_tbl
                    headers.ipv4.dstAddr=10.10.10.10,action=pipe.push_mpls(10)
    """
    priority_val = None
    grp_id = 0
    mem_id = 0

    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)

    if (flow.find("group_id") != -1 or flow.find("member_id") != -1):
        # For TableAction when we use type as action_profile_member_id or
        # action_profile_group_id, p4rt-ctl expects either group_id or
        # member_id as part of flow. Hence delimiter as 'action=' doesnt work
        # here. Use parse_flow_as in this case, where we use ',' as a delimiter
        match_keys, action, action_data, grp_id, mem_id = parse_flow_as(flow)
    elif (flow.find("priority") != -1):
        # For match_type ternary, we expect priority to be programmed by user.
        match_keys, priority_val, action, action_data = parse_flow_ternary(flow, helper)
    else:
        # For TableAction when we use type as Action, p4rt-ctl expects flow to
        # have an 'action=' configured. In this parse_flow, we use 'action=' as
        # a delimiter.
        match_keys, action, action_data = parse_flow(flow, helper)

    te = helper.buildTableEntry(
        table_name=tbl_name,
        match_fields=match_keys,
        action_name=action,
        action_params=action_data
                       if (action_data==None or action_data==[''])
                       else {a.name: int(action_data[idx]) for idx,
                       a in enumerate(helper.get_action_params(action))},
        priority=priority_val,
        group_id=int(grp_id),
        member_id=int(mem_id))

    update = p4runtime_pb2.Update()
    update.type = p4runtime_pb2.Update.MODIFY
    update.entity.table_entry.CopyFrom(te)

    client.write_update(update)



@with_client
def p4ctl_set_default_entry(client, bridge, tbl_name, action):
    """
    set-default-entry SWITCH TABLE ACTION
    Example:
        p4rt-ctl set-default-entry br0 pipe.filter_tbl pipe.push_mpls(10)
    """

    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))
    helper = P4InfoHelper(p4info)

    action_name, action_data = parse_action(action)
    te = helper.buildTableEntry(
        table_name=tbl_name,
        default_action=True,
        action_name=action_name,
        action_params={a.name: int(action_data[idx]) for idx,
                       a in enumerate(helper.get_action_params(action_name))})

    update = p4runtime_pb2.Update()
    update.type = p4runtime_pb2.Update.MODIFY
    update.entity.table_entry.CopyFrom(te)

    client.write_update(update)


@with_client
def p4ctl_get_default_entry(client, bridge, tbl_name):
    """
    get-default-entry SWITCH TABLE
    Example:
        p4rt-ctl get-default-entry br0 pipe.filter_tbl
    """
    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))
    helper = P4InfoHelper(p4info)

    entity = p4runtime_pb2.Entity()
    table_entry = entity.table_entry
    table_entry.table_id = helper.get_tables_id(tbl_name)
    table_entry.is_default_action = True

    print("Default table entry for bridge {}:".format(bridge))
    for response in client.read_one(entity):
            for entry in response.entities:
                try:
                    print(_format_entry(helper, entry.table_entry))
                except AttributeError:
                    print(" No default entry set!")


@with_client
def p4ctl_del_entry(client, bridge, tbl_name, match_key):
    priority = None
    if (match_key.find("priority") != -1):
        # For match_type ternary, we expect priority to be set by user.
        key, priority = parse_match_key_ternary(match_key)
    else:
        key = parse_match_key(match_key)

    p4info = client.get_p4info()

    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)

    te = helper.buildTableEntry(
        table_name=tbl_name,
        match_fields=key,
        priority=priority,
    )

    update = p4runtime_pb2.Update()
    update.type = p4runtime_pb2.Update.DELETE

    update.entity.table_entry.CopyFrom(te)

    client.write_update(update)


def _format_entry(p4info_helper, table_entry):
    tbl_name = p4info_helper.get_name('tables', table_entry.table_id)
    output_buffer = "  "
    output_buffer += "table={}".format(tbl_name)
    if table_entry.priority is not None and table_entry.priority != 0:
        output_buffer += " priority={}".format(table_entry.priority)

    first = True
    for mf in table_entry.match:
        match_field_name = p4info_helper.get_match_field_name(tbl_name,
                                                              mf.field_id)
        mf_val = p4info_helper.get_match_field_value(mf)
        if type(mf_val) == tuple:
            mf_val = "{}/{}".format(decodeToHex(mf_val[0]), mf_val[1])
        else:
            mf_val = decodeToHex(mf_val)
        if first:
            output_buffer += " {}={}".format(match_field_name, mf_val)
            first = False
        else:
            output_buffer += ",{}={}".format(match_field_name, mf_val)

    if table_entry.action.action.action_id is not None and \
       table_entry.action.action.action_id != 0:
        output_buffer += ' actions='
        action_name = p4info_helper.get_name('actions',
                                         table_entry.action.action.action_id)
        action_params = p4info_helper.get_action_params(action_name)
        params_str = ""
        for idx, param in enumerate(table_entry.action.action.params):
            params_str += "{}={}".format(action_params[idx].name,
                                     decodeToHex(param.value))
        output_buffer += '{}({})'.format(action_name, params_str)

    if table_entry.action.action_profile_member_id is not None and \
       table_entry.action.action_profile_member_id != 0:
       output_buffer += ' actions='
       action_name = ' member_id'
       params_str =  table_entry.action.action_profile_member_id
       output_buffer += '{}({})'.format(action_name, params_str)

    if table_entry.action.action_profile_group_id is not None and \
       table_entry.action.action_profile_group_id != 0:
       output_buffer += ' actions='
       action_name = ' group_id'
       params_str =  table_entry.action.action_profile_group_id
       output_buffer += '{}({})'.format(action_name, params_str)

    # Need to add support for action_profile_action_set, currently not supported.

    return output_buffer

def _format_member(p4info_helper, apm):
    apm_name = p4info_helper.get_name('action_profiles', apm.action_profile_id)
    output_buffer = "  "
    output_buffer += "action_profiles={}".format(apm_name)

    output_buffer += ' actions='
    action_name = p4info_helper.get_name('actions',
                                         apm.action.action_id)
    action_params = p4info_helper.get_action_params(action_name)
    params_str = ""
    for idx, param in enumerate(apm.action.params):
        params_str += "{}={}".format(action_params[idx].name,
                                     int.from_bytes(param.value, "big"))
    output_buffer += '{}({})'.format(action_name, params_str)

    return output_buffer

def _format_group(p4info_helper, apg):
    apm_name = p4info_helper.get_name('action_profiles', apg.action_profile_id)
    output_buffer = "  "
    output_buffer += "action_profiles={}".format(apm_name)

    output_buffer += ' reference_members='

    converted_list = [str(member.member_id) for member in apg.members]
    params_str = ",".join(converted_list)

    output_buffer += '({})'.format(params_str)

    output_buffer += ' max_size=' + str(apg.max_size)

    return output_buffer

@with_client
def p4ctl_dump_entries(client, bridge, tbl_name=None):
    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))
    helper = P4InfoHelper(p4info)
    entity = p4runtime_pb2.Entity()
    table_entry = entity.table_entry

    if not tbl_name:
        table_entry.table_id = 0
    else:
        table_entry.table_id = helper.get_tables_id(tbl_name)

    print("Table entries for bridge {}:".format(bridge))
    for response in client.read_one(entity):
        for entry in response.entities:
            print(_format_entry(helper, entry.table_entry))

@with_client
def p4ctl_add_group(client, bridge, tbl_name, flow):
    """
    add-action-profile-group SWITCH TABLE GROUP_ID MEMBER_ID/ACTIONS MAX_SIZE
    Example:
        p4rt-ctl add-action-profile-group br0 pipe.filter_tbl
                    group_id=1,reference_members=(1,2),max_size=2
    """
    group_id, members, max_size = parse_profile_group(flow)
    if int(group_id) == 0:
        print("Group ID 0 is unsupported.")
        return

    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)

    apg = helper.buildActionProfileGroup(
        table_name=tbl_name,
        group_id=int(group_id),
        max_size=int(max_size),
        members=members)

    update = p4runtime_pb2.Update()
    update.type = p4runtime_pb2.Update.INSERT
    update.entity.action_profile_group.CopyFrom(apg)

    client.write_update(update)

@with_client
def p4ctl_mod_group(client, bridge, tbl_name, flow):
    """
    modify-action-profile-group SWITCH TABLE GROUP_ID
                                MEMBER_ID/ACTIONS MAX_SIZE
    Example:
        p4rt-ctl modify-action-profile-group br0 pipe.filter_tbl
                   group_id=1,reference_members=(1,2),max_size=2
    """

    group_id, members, max_size = parse_profile_group(flow)
    if int(group_id) == 0:
        print("Group ID 0 is unsupported.")
        return

    print("Backend target does not currently support Modify Group.")
    print("Instead, delete group:", group_id, "and re-add same group with "
          "members:", members, " size:", max_size)
    return

    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)

    apg = helper.buildActionProfileGroup(
        table_name=tbl_name,
        group_id=int(group_id),
        max_size=int(max_size),
        members=members)

    update = p4runtime_pb2.Update()
    update.type = p4runtime_pb2.Update.MODIFY
    update.entity.action_profile_group.CopyFrom(apg)

    client.write_update(update)

@with_client
def p4ctl_del_group(client, bridge, tbl_name, flow):
    """
    delete-action-profile-group SWITCH TABLE GROUP_ID
    Example:
        p4rt-ctl delete-action-profile-group br0 pipe.filter_tbl
                  group_id=1
    """
    group_id = flow.split("group_id=")[1]
    if int(group_id) == 0:
        print("Group ID 0 is unsupported.")
        return

    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)
    apg = helper.buildActionProfileGroup(
          table_name=tbl_name,
          group_id=int(group_id))

    update = p4runtime_pb2.Update()
    update.type = p4runtime_pb2.Update.DELETE
    update.entity.action_profile_group.CopyFrom(apg)

    client.write_update(update)

@with_client
def p4ctl_add_member(client, bridge, tbl_name, flow):
    """
    add-action-profile-member SWITCH TABLE ACTION ACTION_DATA MEMBER_ID
    Example:
        p4rt-ctl add-action-profile-member br0 pipe.filter_tbl
                    action=pipe.push_mpls(10),member_id=1
    """
    action, action_data, mem_id = parse_profile_mem(flow)
    if int(mem_id) == 0:
        print("Member ID 0 is unsupported.")
        return

    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)

    apm = helper.buildActionProfileMember(
        table_name=tbl_name,
        member_id=int(mem_id),
        action_name=action,
        action_params={a.name: int(action_data[idx]) for idx,
                       a in enumerate(helper.get_action_params(action))})

    update = p4runtime_pb2.Update()
    update.type = p4runtime_pb2.Update.INSERT
    update.entity.action_profile_member.CopyFrom(apm)

    client.write_update(update)


@with_client
def p4ctl_del_member(client, bridge, tbl_name, flow):
    """
    delete-action-profile-member SWITCH TABLE MEMBER_ID
    Example:
        p4rt-ctl delete-action-profile-member br0 pipe.filter_tbl
                  member_id=1
    """
    member_id = flow.split("member_id=")[1]

    if int(member_id) == 0:
        print("Member ID 0 is unsupported.")
        return

    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)
    apm = helper.buildActionProfileMember(
          table_name=tbl_name,
           member_id=int(member_id))

    update = p4runtime_pb2.Update()
    update.type = p4runtime_pb2.Update.DELETE
    update.entity.action_profile_member.CopyFrom(apm)

    client.write_update(update)


@with_client
def p4ctl_get_member(client, bridge, tbl_name, flow):
    """
    get-action-profile-member SWITCH TABLE MEMBER_ID
    Example:
        p4rt-ctl get-action-profile-member br0 pipe.filter_tbl
                    "member_id=1"
    """

    member_id = flow.split("member_id=")[1]
    if int(member_id) == 0:
        print("Member ID 0 is unsupported.")
        return

    p4info = client.get_p4info()
    if not p4info:
       raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)
    entity = p4runtime_pb2.Entity()
    apm = entity.action_profile_member

    apm.member_id = int(member_id)
    if not tbl_name:
        apm.action_profile_id = 0
    else:
        apm.action_profile_id = helper.get_action_profiles_id(tbl_name)

    print("Action associated with member_id: ", member_id)
    for response in client.read_one(entity):
        for entry in response.entities:
            print(_format_member(helper, entry.action_profile_member))

@with_client
def p4ctl_get_group(client, bridge, tbl_name, flow):
    """
    get-action-profile-group SWITCH TABLE GROUP_ID
    Example:
        p4rt-ctl get-action-profile-group br0 pipe.filter_tbl
                    "group_id=1"
    """
    group_id = flow.split("group_id=")[1]
    if int(group_id) == 0:
        print("Group ID 0 is unsupported.")
        return

    p4info = client.get_p4info()
    if not p4info:
       raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    helper = P4InfoHelper(p4info)
    entity = p4runtime_pb2.Entity()
    apg = entity.action_profile_group

    apg.group_id = int(group_id)
    if not tbl_name:
        apg.action_profile_id  = 0
    else:
        apg.action_profile_id  = helper.get_action_profiles_id(tbl_name)

    print("Members associated with group: ", group_id)
    for response in client.read_one(entity):
        for entry in response.entities:
            print(_format_group(helper, entry.action_profile_group))

def parse_rcflow(flow):
    tmp = flow.split(",")

    cnt_id_str = tmp[0].split("=")
    index_str = tmp[1].split("=")

    if cnt_id_str[0] != "counter_id":
        print("Input error: parameter should be \'counter_id\'")
        sys.exit(1)

    if index_str[0] != "index":
        print("Input error: parameter should be \'index\'")
        sys.exit(1)

    counter_id=cnt_id_str[1]
    index=index_str[1]

    if counter_id.isdigit() is False:
        print("Counter ID: \"{}\" should be numeric value".format(counter_id))
        sys.exit(1)

    if index == "UNSET": #special case for "UNSET"
        index = 0
    elif index.isdigit() is False:
        print("Index: \"{}\" should be numeric value".format(index))
        sys.exit(1)

    return counter_id, index

def _format_dce(ce):
    output_buffer = 'table_id={}'.format(ce.table_entry.table_id)
    output_buffer += ', counter_data=(bytes={},packets={})'.format(ce.data.byte_count, ce.data.packet_count)
    return output_buffer

@with_client
def p4ctl_get_direct_counter_entry(client, bridge, cnt_tbl_name, flow):
    """
    get-direct-counter SWITCH COUNTER_TABLE READ_COUNTER_FLOW
    Example 1: // return direct counter stats for matching key
        p4rt-ctl get-direct-counter br0 my_control.e_fwd
                    "hdrs.mac[vmeta.common.depth].da="0x000000000275",
                    hdrs.mac[vmeta.common.depth].sa="0x9ebace98d9b1""
    """
    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    key = parse_match_key(flow)
    helper = P4InfoHelper(p4info)
    entity = p4runtime_pb2.Entity()
    ce = entity.direct_counter_entry
    if ce is None:
        raise Exception("Cannot find direct_counter_entry field in entity")

    te = helper.buildTableEntry(
         table_name=cnt_tbl_name,
         match_fields=key
     )

    ce.table_entry.CopyFrom(te)
    entity.direct_counter_entry.table_entry.CopyFrom(te)
    for response in client.read_one(entity):
        for entry in response.entities:
            if entity.direct_counter_entry.table_entry.table_id == ce.table_entry.table_id:
                print(_format_dce(entry.direct_counter_entry))

def validate_counter_name_and_id(p4info, cnt_tbl_name, ctr_id):
    for iter in p4info.counters:
        if iter.preamble.name == cnt_tbl_name:
            if int(ctr_id) == 0 or iter.preamble.id == int(ctr_id):
                    return True

    return False

def _format_ce(ce):
    output_buffer = 'counter_id={}, index={}'.format(ce.counter_id, ce.index.index)
    output_buffer += ', counter_data=(bytes={},packets={})'.format(ce.data.byte_count, ce.data.packet_count)
    return output_buffer

@with_client
def p4ctl_get_counter_entry(client, bridge, cnt_tbl_name, flow):
    """
    get-counter-entry SWITCH COUNTER_TABLE READ_COUNTER_FLOW
    Example 1: // COUNTER_ID=0, return full counter table
        p4rt-ctl get-counter br0 ipv4_host_counter
                    "counter_id=0,index=UNSET"
        p4rt-ctl get-counter br0 ipv4_host_counter
                    "counter_id=0,index=2"
    Example 2: // INDEX=UNSET, return all entries matching with counter_id
        p4rt-ctl get-counter br0 ipv4_host_pkt_counter
                    "counter_id=1,index=UNSET"
    Example 3: // return single matching counter entry
        p4rt-ctl get-counter br0 ipv4_host_pkt_counter
                    "counter_id=1,index=2"
    """
    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    ctr_id, idx = parse_rcflow(flow)

    if validate_counter_name_and_id(p4info, cnt_tbl_name, ctr_id) is False:
        print("Error: Could not find counter table \'{}\' or counter_id {} in P4Info".format(cnt_tbl_name, ctr_id))
        sys.exit(1)


    helper = P4InfoHelper(p4info)
    entity = p4runtime_pb2.Entity()
    ce = entity.counter_entry

    if ce is None:
        raise Exception("Cannot find counter_entry field in entity")

    ce.counter_id = int(ctr_id) or 0 #Assign 0 if None

    ce.index.index = int(idx)

    for response in client.read_one(entity):
        for entry in response.entities:
            if entry.counter_entry.counter_id == ce.counter_id and entry.counter_entry.index.index == int(idx):
                print(_format_ce(entry.counter_entry))

@with_client
def p4ctl_reset_counter_entry(client, bridge, cnt_tbl_name, flow):
    """
    reset-counter-entry SWITCH COUNTER_TABLE RESET_COUNTER_FLOW
    Example :
        p4rt-ctl reset-counter br0 pipe.port_bytes_in
                    "counter_id=1,index=2"
    """
    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    ctr_id, idx = parse_rcflow(flow)

    if validate_counter_name_and_id(p4info, cnt_tbl_name, ctr_id) is False:
        print("Error: Could not find counter table \'{}\' or counter_id {} in P4Info".format(cnt_tbl_name, ctr_id))
        sys.exit(1)

    helper = P4InfoHelper(p4info)
    entity = p4runtime_pb2.Entity()
    ce = entity.counter_entry

    if ce is None:
        raise Exception("Cannot find counter_entry field in entity")

    ce.counter_id = int(ctr_id)
    ce.index.index = int(idx)
    ce.data.byte_count = 0
    ce.data.packet_count = 0

    # Send a MODIFY write() request
    update = p4runtime_pb2.Update()
    update.type = p4runtime_pb2.Update.MODIFY
    update.entity.counter_entry.CopyFrom(ce)

    client.write_update(update)

def parse_get_meter_flow(flow):
    tmp = flow.split(",")

    mtr_id_str = tmp[0].split("=")
    index_str = tmp[1].split("=")

    if mtr_id_str[0] != "meter_id":
        print("Input error: parameter should be \'meter_id\'")
        sys.exit(1)

    if index_str[0] != "meter_index":
        print("Input error: parameter should be \'meter_index\'")
        sys.exit(1)

    meter_id=mtr_id_str[1]
    index=index_str[1]

    if meter_id.isdigit() is False:
        print("Meter ID: \"{}\" should be numeric value".format(meter_id))
        sys.exit(1)

    if index.isdigit() is False:
        print("Index: \"{}\" should be numeric value".format(index))
        sys.exit(1)

    return meter_id, index

def _format_me(ce):
    output_buffer = 'meter_id={}, index={}'.format(ce.meter_id, ce.index)
    output_buffer += ', meter_counter_data_green=(bytes={},packets={})'.format(ce.counter_data.green.byte_count, ce.counter_data.green.packet_count)
    output_buffer += ', meter_counter_data_yellow=(bytes={},packets={})'.format(ce.counter_data.yellow.byte_count, ce.counter_data.yellow.packet_count)
    output_buffer += ', meter_counter_data_red=(bytes={},packets={})'.format(ce.counter_data.red.byte_count, ce.counter_data.red.packet_count)
    return output_buffer

def _format_dme(ce):
    pdb.set_trace()
    output_buffer = 'table_id={}'.format(ce.table_entry.table_id)
    output_buffer += ', direct_meter_counter_data_green=(bytes={},packets={})'.format(ce.counter_data.green.byte_count, ce.counter_data.green.packet_count)
    output_buffer += ', direct_meter_counter_data_yellow=(bytes={},packets={})'.format(ce.counter_data.yellow.byte_count, ce.counter_data.yellow.packet_count)
    output_buffer += ', direct_meter_counter_data_red=(bytes={},packets={})'.format(ce.counter_data.red.byte_count, ce.counter_data.red.packet_count)
    return output_buffer

@with_client
def p4ctl_get_packet_mod_meter_entry(client, bridge, tbl_name, flow):
    """
    p4ctl-get-packet-mod-meter-entry SWITCH METER_TABLE READ_METER_FLOW
    Example : // return single matching meter entry
        p4rt-ctl get-packet-mod-meter br0 my_control.meter1 "meter_id=2244878476,meter_index=6"
    """
    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    mtr_id, idx = parse_get_meter_flow(flow)

    helper = P4InfoHelper(p4info)
    entity = p4runtime_pb2.Entity()
    ce = entity.meter_entry

    if ce is None:
        raise Exception("Cannot find meter_entry field in entity")

    ce.meter_id = int(mtr_id) or 0 #Assign 0 if None
    ce.index.index = int(idx)

    for response in client.read_one(entity):
        for entry in response.entities:
            if entry.meter_entry.meter_id == ce.meter_id and entry.meter_entry.index.index == int(idx):
                print(_format_me(entry.meter_entry))

@with_client
def p4ctl_get_direct_pkt_mod_meter_entry(client, bridge, tbl_name, flow):
    """
    get-direct-pkt-mod-meter SWITCH METER_TABLE READ_METER_FLOW
    Example 1: // return direct meter stats for matching key
        p4rt-ctl get-direct-pkt-mod-meter br0 my_control.e_fwd
                    "hdrs.mac[vmeta.common.depth].da="0x000000000275",
                    hdrs.mac[vmeta.common.depth].sa="0x9ebace98d9b1""
    """
    p4info = client.get_p4info()
    if not p4info:
        raise Exception("cannot retrieve P4Info from device {}".format(bridge))

    key = parse_match_key(flow)
    helper = P4InfoHelper(p4info)
    entity = p4runtime_pb2.Entity()
    ce = entity.direct_meter_entry
    if ce is None:
        raise Exception("Cannot find direct_meter_entry field in entity")

    te = helper.buildTableEntry(
         table_name=cnt_tbl_name,
         match_fields=key
     )

    ce.table_entry.CopyFrom(te)
    entity.direct_meter_entry.table_entry.CopyFrom(te)
    for response in client.read_one(entity):
        for entry in response.entities:
            if entity.direct_meter_entry.table_entry.table_id == ce.table_entry.table_id:
                print(_format_dme(entry.direct_meter_entry))

all_commands = {
    "show": (p4ctl_show, 1),
    "set-pipe": (p4ctl_set_pipe, 3),
    "start-pktio": (p4ctl_start_pktio, 1),
    "get-pipe": (p4ctl_get_pipe, 1),
    "add-entry": (p4ctl_add_entry, 3),
    "modify-entry": (p4ctl_mod_entry, 3),
    "set-default-entry": (p4ctl_set_default_entry, 3),
    "get-default-entry": (p4ctl_get_default_entry, 2),
    "del-entry": (p4ctl_del_entry, 2),
    "dump-entries": (p4ctl_dump_entries, 1),
    "add-action-profile-member": (p4ctl_add_member, 3),
    "delete-action-profile-member": (p4ctl_del_member, 3),
    "add-action-profile-group": (p4ctl_add_group, 3),
    #"modify-action-profile-group": (p4ctl_mod_group, 3),
    "delete-action-profile-group": (p4ctl_del_group, 3),
    "get-action-profile-member": (p4ctl_get_member, 3),
    "get-action-profile-group": (p4ctl_get_group, 3),
    "get-counter" : (p4ctl_get_counter_entry, 2),
    "get-direct-counter" : (p4ctl_get_direct_counter_entry, 2),
    "reset-counter" : (p4ctl_reset_counter_entry, 2),
    "add-meter-config" : (p4ctl_add_meter_config, 3),
    "get-packet-mod-meter" : (p4ctl_get_packet_mod_meter_entry, 2),
    "get-direct-pkt-mod-meter" : (p4ctl_get_direct_pkt_mod_meter_entry, 2)
}


def validate_args(argv, command, expected_nr):
    if len(argv)-2 < expected_nr:
        raise Exception("p4rt-ctl: '{}' command requires at least {} "
                        "arguments".format(command, expected_nr))

# Global variable
grpc_server_addr = ""

def main():
    global grpc_server_addr
    if len(sys.argv) < 2:
        print("p4rt-ctl: missing command name; use --help for help")
        sys.exit(1)
    parser = argparse.ArgumentParser(usage=USAGE)
    parser.add_argument('-g', '--grpc_addr', required=False, type=str, help="P4Runtime gRPC server address, format : <server IP>:<port>")
    parser.add_argument('command', nargs='*', help='Subcommand to run')
    args = parser.parse_args()
    if args.grpc_addr is None:
        grpc_server_addr = 'localhost:9559'
    else:
        ip_addr = args.grpc_addr.split(":");
        if valid_ip(ip_addr[0]):
            grpc_server_addr = str(args.grpc_addr)
        else:
            print("Invalid IP address for GRPC server ")
            system.exit(1)
    if args.command[0] not in all_commands.keys():
        usage()


    try:
        # use dispatch pattern to invoke method with same name
        # but first validate number of arguments
        validate_args(sys.argv, command=args.command[0],
                      expected_nr=all_commands[args.command[0]][1])
        all_commands[args.command[0]][0](*args.command[1:])

    except Exception as e:
        print("Error:", str(e))
        sys.exit(1)


if __name__ == '__main__':
    main()
